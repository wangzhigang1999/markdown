# 线程

线程（英語：thread）是操作系统能夠進行運算调度的最小單位。 大部分情况下，它被包含在进程之中，是进程中的實際運作單位。 一条线程指的是进程中一个单一顺序的控制流，一個进程中可以並行多個线程，每条线程并行执行不同的任务。

## 线程的状态

![img](%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/137084-20180421113325399-1759953729.jpg)

# Signal和notify

- 每java对象都有一个内部对象锁
- 每个内部对象锁有且仅有一个条件

- 调用一个对象的 `wait/notify` 方法等价于调用这个==条件== 的 `await/signal` 方法
- 因为 `wait/notify` 方法是==object==类的==final==方法,因此 才会在命名上进行区分

#  Synchronize

> Synchronize的锁的对象是方法的 **调用者**

> 加在静态方法上的 Synchronize 锁的对象是 .class 模板 , 全局唯一的 .

```Java
/**
 * @author wangz
 */
public class Main {
    public static void main(String[] args) {
        Ticket ticket = new Ticket();
        new Thread(ticket::sale).start();
        new Thread(ticket::sale).start();
        new Thread(ticket::sale).start();
    }
}

class Ticket {
    int num = 20;

    public synchronized void sale() {
        if (num > 0) {
            System.out.println("卖出了第" + num + "张票");
            num--;
        }
    }
}
```

> 使用Synchronize实现两个线程轮流打印数字

```Java
/**
 * @author wangz
 * 在两个线程的情况下,方法不加 Synchronized 不会有问题
 */
public class Main {
    public static void main(String[] args) {
        Data data = new Data();
        new Thread(() -> {
            for (int i = 0; i < 10; i++) {
                try {
                    data.threadOne();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "    ONE").start();

        new Thread(() -> {
            for (int i = 0; i < 10; i++) {
                try {
                    data.threadTwo();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "    TWO").start();

    }
}

class Data {
    boolean flag = false;
    static int num = 0;

    public synchronized void threadOne() throws InterruptedException {
        if (flag) {
            this.wait();
        }
        System.out.println(++num + Thread.currentThread().getName());
        flag = true;
        this.notifyAll();

    }

    public synchronized void threadTwo() throws InterruptedException {
        if (!flag) {
            this.wait();
        }
        System.out.println(++num + Thread.currentThread().getName());
        flag = false;
        this.notifyAll();
    }
}
```



- 注意,wait会产生虚假唤醒的问题. 使用 **if** 仅会进行一次判断.  更改为 while 可以解决这个问题.

  ![image-20200224211640618](%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20200224211640618.png)

- synchronize 的内部锁有一定的局限
  - 不能中断一个正在试图获得锁的线程
  - 试图获得锁时不能设定超时
  - 每个锁仅有单一的条件

## 简介

​	Synchronized的同步是基于进入和退出监视器对象（Monitor）来实现的。对于同步代码块，编译器会在自动在前后加上monitorenter和monitorexit指令, 一个enter 对应两个 exit,这是保证出现异常仍可以解锁不会出现死锁.

​	对于同步方法，编译器会自动在方法标识上加上ACC_SYNCHRONIZED来表示这个方法为同步方法。

​	synchronized是通过争抢对象关联的Monitor实现的,但是重量级锁需要在用户态和内核态之间切换,因此开销

比较大.但是现在的优化使用锁升级,大大降低了开销,因此十分推荐使用synchronize.

## Java对象布局

用 jol-core 工具查看对象布局

64位虚拟机的一个对象最下为 16字节 , 12字节对象头+四字节对齐填充.  8B的整数倍.

在64位虚拟机中,对象头的前 8B表示 MarkWord

后边的4B表示 classMetaAddress,类型指针,表示这是哪个类的实例

> java对象状态

- 无状态
- 偏向锁
- 轻量锁
- 重量锁
- 引用不存在

> java对象头布局

![image-20200628183455744](%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20200628183455744.png)

## 对象监视器

ObjectMonitor中有两个队列，_WaitSet 和 _EntryList，用来保存ObjectWaiter对象列表( 每个等待锁的线程都会被封装成ObjectWaiter对象)，_owner指向持有ObjectMonitor对象的线程，当多个线程同时访问一段同步代码时，首先会进入 _EntryList 集合，当线程获取到对象的monitor后进入_Owner区域并把monitor中的owner变量设置为当前线程同时monitor中的计数器count加1，若线程调用wait()方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入 WaitSet集合中等待被唤醒。若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便其他线程进入获取monitor(锁)。如下图所示：

![img](%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image.png)

## 锁升级

### 偏向锁

- 先到先得,用非常轻量级的东西 (线程ID) 写到markWord中
- 没有锁竞争机制

> 偏向锁不一定比自旋锁效率高

​		在明确知道会有多个线程的情况下,使用偏向锁会导致锁撤销,消耗资源, 此时应该直接使用自旋锁.

- 默认4s后打开偏向锁

  匿名偏向锁 : 没有偏向任意线程

### 轻量级锁

- 当竞争加剧的时候,JVM会使用自旋操作.当到达全局安全点（safepoint）时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。
- 每个线程在自己的栈中生成 `LR`(lockRecord) ,同时自旋的将自己的 LR 写入标记字中
- 未获得锁的线程继续自旋

### 重量级锁

- 竞争更加激烈,则需要向操作系统申请
- 有线程自旋的次数超过 `10`次,升级成重量级锁
- 调用了wait方法直接由轻量级锁升级成重量级锁
- 重量级锁中包含队列

> 为什么需要重量级锁

​		大量的线程自旋会导致CPU资源的浪费

# Lock

lock是一个接口.

lock与Synchronize的区别:

- lock 是接口,Synchronize是一个内置的关键字
- lock需要手动上锁解锁,Synchronize是自动上锁解锁
- lock锁可以解决阻塞问题,Synchronize不能解决
- Synchronize是非公平锁,不可改变的
- Synchronize适合锁少量的代码
- lock比较灵活
- synchronize 不能精准唤醒
- lock必须匹配,加锁多于解锁会死锁,加锁少于解锁会`IllegalMonitorStateException`非法监视器状态异常

##  ReentrantLock

> 可重入指的是可以自动拥有某个锁里边的所有相同的锁, 即 ==一重一重== 的,不是出去又进来. (递归锁)

- 可以有效防止死锁
- 获得的所有锁都是同一把

```java
class Ticket {
    int num = 20;

    Lock lock = new ReentrantLock();

    public void sale() {
        lock.lock();
        System.out.println("卖出了第" + num + "张票");
        num--;
        lock.unlock();
    }
}
```

- 可重入锁分为公平式锁和非公平锁,默认是非公平的.


```Java
private final Sync sync;

public ReentrantLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();
}
```

可以看到, 在 ReentrantLock 中, 比较有意义的字段为 ==sync== , 构造器会将其赋值为 ==FairSync== 或 ==NonfairSync==,这两者均继承一个Sync的 **静态抽象内部类**.

<img src="%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20200224201811903.png" alt="image-20200224201811903" style="zoom: 67%;" />

> lock版本的生产者消费者模式

- lock 代替了 Synchronize 
- condition.await() 代替了 wait
- condition.signal()代替了 signalAll

```Java
static class Data {
    Lock lock = new ReentrantLock();
    Condition condition = lock.newCondition();
    boolean flag = false;
    static int num = 0;

    public void threadOne() throws InterruptedException {
        lock.lock();
        while (flag) {
            condition.await();
        }
        flag = true;
        System.out.println(++num);
        condition.signalAll();

        lock.unlock();
    }

    public void threadTwo() throws InterruptedException {
        lock.lock();
        while (!flag) {
            condition.await();
        }
        flag = false;
        System.out.println(++num);
        condition.signalAll();

        lock.unlock();
    }
}
```

> 使用 Conditional 实现精准通知

```Java
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @author wangz
 */
public class Main {
    public static void main(String[] args) {
        Data data = new Data();
        new Thread(() -> {
            for (int i = 0; i < 10; i++) {
                data.A();
            }
        }).start();
        new Thread(() -> {
            for (int i = 0; i < 10; i++) {
                data.B();
            }
        }).start();
        new Thread(() -> {
            for (int i = 0; i < 10; i++) {
                data.C();
            }
        }).start();

    }
}

class Data {
    Lock lock = new ReentrantLock();
    static int num = 1;
    Condition condition1 = lock.newCondition();
    Condition condition2 = lock.newCondition();
    Condition condition3 = lock.newCondition();

    public void A() {
        lock.lock();

        try {

            while (num != 1) {
                condition1.await();
            }
            System.out.println("A");
            num = 2;
            condition2.signal();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }

    }


    public void B() {
        lock.lock();

        try {
            while (num != 2) {
                condition2.await();
            }
            num = 3;
            System.out.println("B");
            condition3.signal();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }

    }

    public void C() {
        lock.lock();
        try {
            while (num != 3) {
                condition3.await();
            }
            System.out.println("C");
            num = 1;
            condition1.signal();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }

    }

}
```



## ReentrantReadWriteLock

-  维护一对锁,读的时候可以由多个线程读,写的时候只能有一个线程写.
- 仍然是一个接口

```java　
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

/**
 * @author wangz
 */
public class Main {
    public static void main(String[] args) {
        Cache cache = new Cache();
        
        for (int i = 0; i < 10; i++) {
            int finalI = i;
            new Thread(() -> cache.put(String.valueOf(finalI),finalI),String.valueOf(finalI)).start();
        }
        
        for (int i = 0; i < 10; i++) {
            int finalI = i;
            new Thread(() -> cache.get(String.valueOf(finalI)), String.valueOf(finalI)).start();
        }

    }
}

class Cache {
    private volatile Map<String, Object> map = new HashMap<>();
    private ReadWriteLock readWriteLock = new ReentrantReadWriteLock(true);

    public void put(String key, Object val) {
        readWriteLock.writeLock().lock();
        System.out.println("线程" + Thread.currentThread().getName() + " 执行了 put 操作 开始写入");
        map.put(key, val);
        System.out.println("线程" + Thread.currentThread().getName() + " 执行了 put 操作 写入完毕");

        readWriteLock.writeLock().unlock();
    }

    public void get(String key) {
        readWriteLock.readLock().lock();
        System.out.println("线程" + Thread.currentThread().getName() + " 执行了 get 方法   " + map.get(key).toString());
        readWriteLock.readLock().unlock();
    }
}
```

## StampedLock

前面的`ReadWriteLock`可以解决多线程同时读，但只有一个线程能写的问题。

如果我们深入分析`ReadWriteLock`，会发现它有个潜在的问题：如果有线程正在读，写线程需要等待读线程释放锁后才能获取写锁，即读的过程中不允许写，这是一种悲观的读锁。

要进一步提升并发执行效率，Java 8引入了新的读写锁：`StampedLock`。

`StampedLock`和`ReadWriteLock`相比，改进之处在于：读的过程中也允许获取写锁后写入！这样一来，我们读的数据就可能不一致，所以，需要一点额外的代码来判断读的过程中是否有写入，这种读锁是一种乐观锁。

乐观锁的意思就是乐观地估计读的过程中大概率不会有写入，因此被称为乐观锁。反过来，悲观锁则是读的过程中拒绝有写入，也就是写入必须等待。显然乐观锁的并发效率更高，但一旦有小概率的写入导致读取的数据不一致，需要能检测出来，再读一遍就行。

```Java
class Point {
    private final StampedLock stampedLock = new StampedLock();

    private double x;
    private double y;

    // 写入和ReentrantReadWriteLock是一样的,悲观锁
    public void move(double deltaX, double deltaY) {
        long stamp = stampedLock.writeLock(); // 获取写锁
        try {
            x += deltaX;
            y += deltaY;
        } finally {
            stampedLock.unlockWrite(stamp); // 释放写锁
        }
    }

    //读取的时候先使用一个乐观锁,读取一次之后与之前的时间戳对比,若相同则完成读取,否则升级为悲观锁
    public double distanceFromOrigin() {
        long stamp = stampedLock.tryOptimisticRead(); // 获得一个乐观读锁
        // 注意下面两行代码不是原子操作
        // 假设x,y = (100,200)
        double currentX = x;
        // 此处已读取到x=100，但x,y可能被写线程修改为(300,400)
        double currentY = y;
        // 此处已读取到y，如果没有写入，读取是正确的(100,200)
        // 如果有写入，读取是错误的(100,400)
        if (!stampedLock.validate(stamp)) { // 检查乐观读锁后是否有其他写锁发生
            stamp = stampedLock.readLock(); // 获取一个悲观读锁
            try {
                currentX = x;
                currentY = y;
            } finally {
                stampedLock.unlockRead(stamp); // 释放悲观读锁
            }
        }
        return Math.sqrt(currentX * currentX + currentY * currentY);
    }
}
```

> 版本检验

调用`tryOptimisticRead`方法会返回一个根据当前的state状态获得的戳,当读取完成时,先加上内存屏障,然后再比较当前的戳和之前的戳是否一样. 相同说明正常,不相同则升级为悲观锁.

## 公平锁/非公平锁

- 公平锁 按照申请锁的顺序来获取锁
- 非公平 不是按照先来后到



- 非公平锁的吞吐量大

![image-20200422181859743](%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20200422181859743.png)

## 自旋锁

- 尝试获取锁的线程不会阻塞, 会采取循环的方式尝试获取锁.
- 好处是减少上下文切换
- 缺点循环会消耗CPU

> 手写自旋锁代码,结合多线程加法

```java
import java.util.concurrent.atomic.AtomicBoolean;

public class SpinLock {

    AtomicBoolean atomicBoolean = new AtomicBoolean(false);

    public void lock() {
        while (!atomicBoolean.compareAndSet(false, true)) {
            System.out.println("等待获取锁中  " + Thread.currentThread().getName());
        }

    }

    public void unLock() {
        atomicBoolean.compareAndSet(true, false);
    }
}

class Num {
    int num = 0;
    public void add() {
        num++;
    }
}


class SpinLockTest {
    public static void main(String[] args) {
        SpinLock spinLock = new SpinLock();
        Num num = new Num();
        for (int i = 0; i < 100; i++) {
            new Thread(() -> {
                spinLock.lock();
                for (int i1 = 0; i1 < 10000; i1++) {
                    num.add();
                }
                spinLock.unLock();
            }, String.valueOf(i)).start();
        }

        while (Thread.activeCount()>2){
            Thread.yield();
        }

        System.out.println(num.num);

    }
}
```

## 死锁实现

```java
import java.util.concurrent.TimeUnit;

public class DDL implements Runnable {
    final String lockA;
    final String lockB;

    public DDL(String lockA, String lockB) {
        this.lockA = lockA;
        this.lockB = lockB;
    }


    @Override
    public void run() {
        synchronized (lockA){
            System.out.println("获得了"+lockA);
            try {
                TimeUnit.SECONDS.sleep(2);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            synchronized (lockB){
                System.out.println("获得了"+lockB);
            }
        }
    }
}


class DDlTEST{

    public static void main(String[] args) {
        String a="lockA";
        String b="lockB";
        new Thread(new DDL(a,b)).start();
        new Thread(new DDL(b,a)).start();
    }
}
```

- jps
- jstack

# 常见的辅助类

- 这些类是为了使多个线程之间协作效率更高

## CountDownLatch

- 这是一个计数器,但不是计时器
- ==countDownLatch.countDown();==　计数减一
- ==countDownLatch.await();==　　等待归零

```Java
import java.util.concurrent.CountDownLatch;

public class CounterDown {
    public static void main(String[] args) throws InterruptedException {
        CountDownLatch countDownLatch = new CountDownLatch(6);
        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                System.out.println("走了");
                countDownLatch.countDown();
            }).start();
        }
        countDownLatch.await();
        System.out.println("关门");
    }
}
```

## CyclicBarrier

- 与上边的CountDownLatch相似，但这是一个加法计数器。
- 两个构造方法。

- `public CyclicBarrier(int parties, Runnable barrierAction) {}` 
- `public CyclicBarrier(int parties) {}`

```Java
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;

public class Add {
    public static void main(String[] args) {
        CyclicBarrier cyclicBarrier = new CyclicBarrier(7, () -> System.out.println("召唤神龙"));

        for (int i = 0; i < 7; i++) {
            new Thread(() -> {
                System.out.println("龙珠 + 1");
                try {
                    cyclicBarrier.await();
                } catch (InterruptedException | BrokenBarrierException e) {
                    e.printStackTrace();
                }
            }).start();
        }

    }
}
```

## Semaphore

- 限流的时候可以使用到

- 类似一个抢车位的游戏
- 车位的数量是固定的 `Semaphore semaphore = new Semaphore(3);`
- `semaphore.acquire();` 获得一个车位,如果已经满了,等待.
- `semaphore.release();` 放弃当前的车位.

```Java
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;

public class semaphore {
    public static void main(String[] args) {
        Semaphore semaphore = new Semaphore(3);

        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                try {
                    semaphore.acquire();
                    System.out.println("进入的线程是" + Thread.currentThread().getName());
                    TimeUnit.SECONDS.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    System.out.println("离开的线程是" + Thread.currentThread().getName());
                    semaphore.release();
                }
            }, String.valueOf(i)).start();
        }
    }

}
```

# ThreadPool

## 概览

![image-20200701131722621](%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20200701131722621.png)

- 为什么要使用?
  - new 一个对象再回收会导致资源消耗
  - 考虑资源复用来减小开销

> Executors 工具类 生产中不能用

- 包含三种线程池
  - 单线程池
  - 固定大小线程池
  - 可伸缩线程池

```Java
Executors.newSingleThreadExecutor();
Executors.newFixedThreadPool(1);
Executors.newCachedThreadPool();
```



- 线程池用完必须关闭

```Java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * @author wangz
 */
public class ThreadPool {
    public static void main(String[] args) {
        ExecutorService executorService = Executors.newSingleThreadExecutor();

        executorService.execute(()-> System.out.println("hello"));

        executorService.shutdown();

    }
}
```

> 核心技术

- Excutor的本质是  ThreadPoolExecutor

```java
public ThreadPoolExecutor(   
    int corePoolSize,// 核心线程大小
    
    int maximumPoolSize,// 最大线程大小
    
    long keepAliveTime,// 存活时间,当线程无事可做等待的最长时间
    
    TimeUnit unit,// 时间单位
     
    BlockingQueue<Runnable> workQueue,// 阻塞队列
    
    ThreadFactory threadFactory, //线程工厂
    
    RejectedExecutionHandler handler // 拒绝策略

) 
```

> 拒绝策略

```java
private static final RejectedExecutionHandler defaultHandler =   new AbortPolicy();
```

- ==AbortPolicy()==  直接抛出异常 `RejectedExecutionException`
- ==DiscardOldestPolicy==   丢弃队列中最老的任务
- ==DiscardPolicy== 丢弃当前任务
- ==CallerRunsPolicy== 由调用线程（提交任务的线程）直接执行此任务

```Java
public static void main(String[] args) {
    ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(
            2,
            Runtime.getRuntime().availableProcessors(),
            12,
            TimeUnit.SECONDS,
            new LinkedBlockingQueue<>(3),
            Executors.defaultThreadFactory(),
            new ThreadPoolExecutor.AbortPolicy()
        //Exception in thread "main" java.util.concurrent.RejectedExecutionException: 
        //Task ThreadPool$$Lambda$15/0x0000000800ba4c40@4769b07b rejected from 				                   //java.util.concurrent.ThreadPoolExecutor@cc34f4d
        //[Running, pool size = 12, active threads = 11, queued tasks = 0, completed tasks = 23]

    );

    for (int i = 0; i < 200; i++) {
        threadPoolExecutor.execute(() -> System.out.println(Thread.currentThread().getName()));
    }

    threadPoolExecutor.shutdown();

}
```

> 线程数目创建的标准

- CPU密集型  线程数 = CPU 核数
- IO密集型     判断十分耗费IO的线程数目,在此基础上增加若干

> 详细

![image-20200423115727585](%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20200423115727585.png)

- 生产实践必须手写线程池,否则会有资源耗尽的风险

## 关键成员变量

```java

// 阻塞队列
private final BlockingQueue<Runnable> workQueue;

// 可重入锁
private final ReentrantLock mainLock = new ReentrantLock();

// 工作线程集合
private final HashSet<Worker> workers = new HashSet<Worker>();
```

## 构造函数

- 线程池的七个核心参数,此处会抛出非法参数异常.

```java
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler)
```

## execute

```java
public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();

    int c = ctl.get();
    if (workerCountOf(c) < corePoolSize) {
        if (addWorker(command, true))
            return;
        c = ctl.get();
    }
    if (isRunning(c) && workQueue.offer(command)) {
        int recheck = ctl.get();
        if (! isRunning(recheck) && remove(command))
            reject(command);
        else if (workerCountOf(recheck) == 0)
            addWorker(null, false);
    }
    else if (!addWorker(command, false))
        reject(command);
}
```



## addWorker

```java
private boolean addWorker(Runnable firstTask, boolean core) {
    // retry 是一个label
    retry:
    

    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);

        // Check if queue empty only if necessary.
        if (rs >= SHUTDOWN &&
            ! (rs == SHUTDOWN &&
               firstTask == null &&
               ! workQueue.isEmpty()))
            return false;

        // 这是一个小的自旋
        for (;;) {
            int wc = workerCountOf(c);
            // 池子满了
            if (wc >= CAPACITY ||
                wc >= (core ? corePoolSize : maximumPoolSize))
                return false;
            if (compareAndIncrementWorkerCount(c))
                break retry;
            c = ctl.get();  // Re-read ctl
            if (runStateOf(c) != rs)
                continue retry;
            // else CAS failed due to workerCount change; retry inner loop
        }
    }

    boolean workerStarted = false;
    boolean workerAdded = false;
    Worker w = null;
    try {
        w = new Worker(firstTask);
        final Thread t = w.thread;
        if (t != null) {
            final ReentrantLock mainLock = this.mainLock;
            mainLock.lock();
            try {
                // Recheck while holding lock.
                // Back out on ThreadFactory failure or if
                // shut down before lock acquired.
                int rs = runStateOf(ctl.get());

                if (rs < SHUTDOWN ||
                    (rs == SHUTDOWN && firstTask == null)) {
                    if (t.isAlive()) // precheck that t is startable
                        throw new IllegalThreadStateException();
                    workers.add(w);
                    int s = workers.size();
                    if (s > largestPoolSize)
                        largestPoolSize = s;
                    workerAdded = true;
                }
            } finally {
                mainLock.unlock();
            }
            if (workerAdded) {
                t.start();
                workerStarted = true;
            }
        }
    } finally {
        if (! workerStarted)
            addWorkerFailed(w);
    }
    return workerStarted;
}
```

## worker

- worker 是一个神奇的东西,继承了 `抽象队列同步器`,也实现了其中的一些方法.
- 以内部类的形式存在

```java
private final class Worker    extends AbstractQueuedSynchronizer implements Runnable{

    /** Thread this worker is running in.  Null if factory fails. */
    final Thread thread;
    /** Initial task to run.  Possibly null. */
    Runnable firstTask;
    /** Per-thread task counter */
    volatile long completedTasks;

    /**
     * Creates with given first task and thread from ThreadFactory.
     * @param firstTask the first task (null if none)
     */
    Worker(Runnable firstTask) {
        setState(-1); // inhibit interrupts until runWorker
        
        // 将传入的runnable对象赋值给当前worker
        this.firstTask = firstTask;
        //从线程工厂获得一个线程对象
        this.thread = getThreadFactory().newThread(this);
    }

    /** Delegates main run loop to outer runWorker  */
    public void run() {
        runWorker(this);
    }

    // Lock methods
    //
    // The value 0 represents the unlocked state.
    // The value 1 represents the locked state.

    protected boolean isHeldExclusively() {
        return getState() != 0;
    }

    protected boolean tryAcquire(int unused) {
        if (compareAndSetState(0, 1)) {
            setExclusiveOwnerThread(Thread.currentThread());
            return true;
        }
        return false;
    }

    protected boolean tryRelease(int unused) {
        setExclusiveOwnerThread(null);
        setState(0);
        return true;
    }

    public void lock()        { acquire(1); }
    public boolean tryLock()  { return tryAcquire(1); }
    public void unlock()      { release(1); }
    public boolean isLocked() { return isHeldExclusively(); }

    void interruptIfStarted() {
        Thread t;
        if (getState() >= 0 && (t = thread) != null && !t.isInterrupted()) {
            try {
                t.interrupt();
            } catch (SecurityException ignore) {
            }
        }
    }
}
```

### runWorker

- 一旦调用了一个runWorker方法,那么他就会一直去获取任务来运行.

```java 
final void runWorker(Worker w) {
    Thread wt = Thread.currentThread();
    Runnable task = w.firstTask;
    w.firstTask = null;
    w.unlock(); // allow interrupts
    boolean completedAbruptly = true;
    try {
        // 当前的存在一个可执行的任务
        while (task != null || (task = getTask()) != null) {
            w.lock();
            
            
            //下边的第一个 if 语句解释参考英文注释
            // If pool is stopping, ensure thread is interrupted;
            // if not, ensure thread is not interrupted.  This
            // requires a recheck in second case to deal with
            // shutdownNow race while clearing interrupt
            if ((runStateAtLeast(ctl.get(), STOP) ||
                 (Thread.interrupted() &&
                  runStateAtLeast(ctl.get(), STOP))) &&
                !wt.isInterrupted())
                wt.interrupt();
            try {
                
               // 正式开始准备执行一个任务,在执行之前要做一些事情,但是jdk并未实现,因此在开发自己的线程池                   时可以重写这一方法.
                beforeExecute(wt, task);
                Throwable thrown = null;
                try {
                    task.run();
                } catch (RuntimeException x) {
                    thrown = x; throw x;
                } catch (Error x) {
                    thrown = x; throw x;
                } catch (Throwable x) {
                    thrown = x; throw new Error(x);
                } finally {
                    // 与before类似,并没有实际的实现,待用户自定义
                    afterExecute(task, thrown);
                }
            } finally {
                task = null;
                w.completedTasks++;
                w.unlock();
            }
        }
        completedAbruptly = false;
    } finally {
        processWorkerExit(w, completedAbruptly);
    }
}
```

### getTask

- 这个方法是与上边那的runWorker配合使用的,worker通过getTask来获取任务运行

```java
private Runnable getTask() {
    boolean timedOut = false; // Did the last poll() time out?

    // 自旋操作,直到取到了一个任务为止
    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);

        // Check if queue empty only if necessary.
        if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {
            decrementWorkerCount();
            return null;
        }

        int wc = workerCountOf(c);

        // Are workers subject to culling?
        boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;

        if ((wc > maximumPoolSize || (timed && timedOut))
            && (wc > 1 || workQueue.isEmpty())) {
            if (compareAndDecrementWorkerCount(c))
                return null;
            continue;
        }

        try {
            Runnable r = timed ?
                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                workQueue.take();
            if (r != null)
                return r;
            timedOut = true;
        } catch (InterruptedException retry) {
            timedOut = false;
        }
    }
}
```

## submit与execute的区别

```java
public Future<?> submit(Runnable task) {
    if (task == null) throw new NullPointerException();
    // 对任务进行进一步的封装,然后再execute
    RunnableFuture<Void> ftask = newTaskFor(task, null);
    execute(ftask);
    return ftask;
}
```

```java
protected <T> RunnableFuture<T> newTaskFor(Runnable runnable, T value) {
    return new FutureTask<T>(runnable, value);
}
```

两者并`没有本质上的区别`,submit之后仍会调用 execute,只是将Runnable对象再次封装为一个返回值为null的FutureTask对象.



# ThreadLocal

![image-20200628213742641](%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20200628213742641.png)

## 背景

Spring中事务部分需要ThreadLocal的支持,在多重调用时,可以取到顶层调用的值.

## demo

代码中,local是共享变量,两个线程一个负责放入,一个负责读出,但实际上并没有起到共享的目的.

```java
public class Main {
    static ThreadLocal<People> local = new ThreadLocal<>();

    public static void main(String[] args) {

        new Thread(() -> {

            try {
                SECONDS.sleep(2);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(local.get());
        }).start();

        new Thread(() -> {

            try {
                SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            local.set(new People());
        }).start();
    }

    static class People {
        int age = 10;
    }
}
```

## set方法

```java
public void set(T value) {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null)
        map.set(this, value);
    else
        createMap(t, value);
}
```

以ThreadLocal对象为key.



首先拿到当前线程对象聚合的 ThreadLocal的map

![image-20200628211242823](%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20200628211242823.png)

```java
ThreadLocalMap getMap(Thread t) {
    return t.threadLocals;
}
```

```java
private void set(ThreadLocal<?> key, Object value) {

    // We don't use a fast path as with get() because it is at
    // least as common to use set() to create new entries as
    // it is to replace existing ones, in which case, a fast
    // path would fail more often than not.

    Entry[] tab = table;
    int len = tab.length;
    int i = key.threadLocalHashCode & (len-1);

    for (Entry e = tab[i];
         e != null;
         e = tab[i = nextIndex(i, len)]) {
        ThreadLocal<?> k = e.get();

        if (k == key) {
            e.value = value;
            return;
        }

        if (k == null) {
            replaceStaleEntry(key, value, i);
            return;
        }
    }

    // 这里的Entry是 弱引用 的子类
    tab[i] = new Entry(key, value);
    int sz = ++size;
    if (!cleanSomeSlots(i, sz) && sz >= threshold)
        rehash();
}
```

# ForkJoin

> 并行执行任务,大数据量提高效率.

![image-20200229213639241](%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20200229213639241.png)

> 工作窃取

- 有两个线程执行任务,一个线程执行完毕,但是另一个仍然在执行.

- 这时,他可以把另一个线程的一部分任务拿过来执行.
- 双端队列



> demo

```java
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.ForkJoinTask;
import java.util.concurrent.RecursiveTask;

/**
 * @author wangz
 */
public class Sum {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        long start = System.currentTimeMillis();

        ForkJoinPool forkJoinPool = new ForkJoinPool();
        ForkJoin forkJoin = new ForkJoin(0, 1000000000);
        ForkJoinTask<Long> submit = forkJoinPool.submit(forkJoin);
        System.out.println(submit.get());
        forkJoinPool.shutdown();
        long end = System.currentTimeMillis();
        System.out.println(end - start + " ms ");
        
    }
}


class ForkJoin extends RecursiveTask<Long> {
    private long start;
    private long end;

    public ForkJoin(long start, long end) {
        this.start = start;
        this.end = end;
    }

    @Override
    protected Long compute() {
        long temp = 10000000;
        if ((end - start) < temp) {
            long sum = 0;
            for (long i = start; i < end; i++) {
                sum += i;
            }
            return sum;
        } else {
            long middle = (start + end) / 2;
            ForkJoin one = new ForkJoin(start, middle);
            one.fork();
            ForkJoin two = new ForkJoin(middle + 1, end);
            two.fork();

            return one.join() + two.join();
        }
    }
}
```

# BlockingQueue 

- 不得不阻塞
- 某些情况阻塞反而更好
- 自动管理了线程的挂起和唤醒
- BlockQueue 是一个接口
- 实现类使用了 condition实现通知

![image-20200422220217911](%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20200422220217911.png)

> 异常处理

![image-20200422221612146](%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20200422221612146.png)

- 特殊值  插入时==bool值== 取出时 ==null==

> SynchronousQueue

- 一个特殊的阻塞队列
- 没有容量,必须消费后才能生产

> 使用阻塞队列实现生产者消费者模式

 

```java
import java.util.UUID;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.TimeUnit;

public class PS {
    private volatile boolean flag = true;
    BlockingQueue<String> queue = new ArrayBlockingQueue<>(3);

    public void pro() throws InterruptedException {
        while (flag) {

            boolean offer = queue.offer(UUID.randomUUID().toString().substring(0, 5), 2L, TimeUnit.SECONDS);

            if (offer) {
                System.out.println("生产成功 ");
            } else {
                System.out.println("生产失败 ");
            }
        }
    }

    public void consumer() throws InterruptedException {
        while (flag) {
            String poll = queue.poll(2L, TimeUnit.SECONDS);

            if (poll != null) {
                System.out.println("获得成功  " + poll);
            } else {
                System.out.println("获得失败");
            }
        }
    }

    public void changeState() {
        this.flag = !flag;
    }
}

class PSTest {
    public static void main(String[] args) throws InterruptedException {
        PS ps = new PS();
        for (int i = 0; i < 20; i++) {
            new Thread(() -> {
                try {
                    ps.pro();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }).start();


            new Thread(() -> {
                try {
                    ps.consumer();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }).start();
        }


    }
}
```

# callable

> 简单使用

```java
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

public class CallAble implements Callable<String> {

    @Override
    public String call() {
        System.out.println("success");
        return "success";
    }
}

class CallTest{
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        var callAble = new CallAble();
        FutureTask<String> task = new FutureTask<>(callAble);
        new Thread(task).start();

        System.out.println(task.get());
    }
}

```

# AQS

抽象队列同步器

## Lock

以ReentrantLock的lock方法为例,首先会调用sync.lock方法

```java
public void lock() {
    sync.lock();
}
```

sync是一个继承了AQS的抽象类,有两个具体的实现方法 FairSync 和NonFairSync,默认是NonFairSync. 以下均为NonFairSync的细节

```java
private final Sync sync;
```

具体的sync方法使用了CAS,将 AQS 中的 `state` 由 0 改为了 1

```java
final void lock() {
    // 尝试上锁,成功则设置当前线程为资源的占有线程
    if (compareAndSetState(0, 1))
        setExclusiveOwnerThread(Thread.currentThread());
    else
        //上锁失败,说明有其他线程正在占用资源,转到acquire方法
        acquire(1);
}
```

> 转入acquire方法

```java
// arg =1
public final void acquire(int arg) {
    if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}
```

> tryAcquire实现

```java
final boolean nonfairTryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    //首先获取资源的状态,如果是0说明没有线程占用,那么给他上锁即可
    int c = getState();
    if (c == 0) {
        if (compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    // 或者当前线程已经占用了资源,将它的重数加一
    else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        if (nextc < 0) // overflow
            throw new Error("Maximum lock count exceeded");
        setState(nextc);
        return true;
    }
    //上锁失败,转入acquireQueued方法
    return false;
}
```

> acquireQueued方法

![image-20200629123559567](%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/image-20200629123559567.png)

如上图所示,初始的时候head和tail都会指向同样的节点,

在添加一个node并且这个node包含的线程获得了锁时,head会指向新的node,tail也会指向新的node,

原来的node被回收. 

后续如果还有 node 来竞争锁,会将这个 node 加入到链表中,同时判断这个 node 的前驱节点是不是 head ,如果是,尝试获取一次锁 , 不是则将其阻塞,等待唤醒.

```java
// 在正式进入acquireQueued方法之前,用当前线程创建一个节点,并使用CAS将这个节点设置为尾结点
private Node addWaiter(Node mode) {
    Node node = new Node(Thread.currentThread(), mode);
    // Try the fast path of enq; backup to full enq on failure
    Node pred = tail;
    if (pred != null) {
        node.prev = pred;
        if (compareAndSetTail(pred, node)) {
            pred.next = node;
            return node;
        }
    }
    enq(node);
    return node;
}
```

```java
// arg = 1 node 是使用当前线程创建的node,应该被放置到了队尾
final boolean acquireQueued(final Node node, int arg) {
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (;;) {
            // 获取当前节点的前驱节点
            final Node p = node.predecessor();
            //如果前驱节点是队首,再尝试获取一下锁
            if (p == head && tryAcquire(arg)) {
                //获取成功,则将当前线程节点设为首节点,从此以后,所有的首节点都会变成持有资源的节点
                setHead(node);
                p.next = null; // help GC
                failed = false;
                return interrupted;
            }
            //当前节点的前驱不是队首,说明有其他等待的线程,则需要判断此时当前线程是否需要阻塞,如果需要则阻               塞当前线程
            if (shouldParkAfterFailedAcquire(p, node) && parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        //最终如果获取锁失败,则取消获取
        if (failed)
            cancelAcquire(node);
    }
}
```

> cancelAcquire

```java
private void cancelAcquire(Node node) {
    // Ignore if node doesn't exist
    if (node == null)
        return;

    node.thread = null;

    // Skip cancelled predecessors
    Node pred = node.prev;
    while (pred.waitStatus > 0)
        node.prev = pred = pred.prev;

    // predNext is the apparent node to unsplice. CASes below will
    // fail if not, in which case, we lost race vs another cancel
    // or signal, so no further action is necessary.
    Node predNext = pred.next;

    // Can use unconditional write instead of CAS here.
    // After this atomic step, other Nodes can skip past us.
    // Before, we are free of interference from other threads.
    node.waitStatus = Node.CANCELLED;

    // If we are the tail, remove ourselves.
    if (node == tail && compareAndSetTail(node, pred)) {
        compareAndSetNext(pred, predNext, null);
    } else {
        // If successor needs signal, try to set pred's next-link
        // so it will get one. Otherwise wake it up to propagate.
        int ws;
        if (pred != head &&
            ((ws = pred.waitStatus) == Node.SIGNAL ||
             (ws <= 0 && compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &&
            pred.thread != null) {
            Node next = node.next;
            if (next != null && next.waitStatus <= 0)
                compareAndSetNext(pred, predNext, next);
        } else {
            unparkSuccessor(node);
        }

        node.next = node; // help GC
    }
}
```

## Unlock

```java
public void unlock() {
    sync.release(1);
}
```

```java
public final boolean release(int arg) {
    // 先尝试释放锁,释放成功往下,否则返回false
    if (tryRelease(arg)) {
        Node h = head;
      
        if (h != null && h.waitStatus != 0)
            unparkSuccessor(h);
        return true;
    }
    return false;
}
```

> tryRelease

```java
// release = 1
protected final boolean tryRelease(int releases) {
    // 因为是可重入锁,因此要进行减法操作
    int c = getState() - releases;
    //如果当前的线程并不持有锁还要释放,则抛出非法监视器异常
    if (Thread.currentThread() != getExclusiveOwnerThread())
        throw new IllegalMonitorStateException();
    boolean free = false;
  
    if (c == 0) {
        free = true;
        // 将占有资源的对象置为 null,表示当前没有占用
        setExclusiveOwnerThread(null);
    }
    // 改变状态 = 0
    setState(c);
    return free;
}
```

> unparkSuccessor

唤醒他的后驱节点

```java
// node = head
private void unparkSuccessor(Node node) {
    /*
     * If status is negative (i.e., possibly needing signal) try
     * to clear in anticipation of signalling.  It is OK if this
     * fails or if status is changed by waiting thread.
     */
    int ws = node.waitStatus;
   	//首先将当前线程的节点的状态改为 0 
    if (ws < 0)
        compareAndSetWaitStatus(node, ws, 0);

    /*
     * Thread to unpark is held in successor, which is normally
     * just the next node.  But if cancelled or apparently null,
     * traverse backwards from tail to find the actual
     * non-cancelled successor.
     */
    Node s = node.next;
    if (s == null || s.waitStatus > 0) {
        s = null;
        // 从后往前遍历,找到最靠近头结点的 waitStatus<=0 的节点 ,将其唤醒
        // waitStatus <= 0 只有以下几种情况
        // static final int SIGNAL = -1 等待唤醒	
        // static final int CONDITION = -2 等待一个condition条件将其唤醒
        // static final int PROPAGATE = -3 The next acquireShared should
        // unconditionally propagate

        for (Node t = tail; t != null && t != node; t = t.prev)
            if (t.waitStatus <= 0)
                s = t;
    }
    if (s != null)
        LockSupport.unpark(s.thread);
}
```

# CAS

==compare and set==  ==乐观锁==

- 如果线程的期望值和内存的真实值,则执行比较并交换.
- CAS 是一条 ==**CPU并发原语**==
- 是一种依赖于硬件的原子操作,属于操作系统用于范畴,是由==若干条指令==组成的原子操作

> UnSafe CAS的核心类

```java
	Exception in thread "main" java.lang.SecurityException: Unsafe
	at jdk.unsupported/sun.misc.Unsafe.getUnsafe(Unsafe.java:98)
```

- 包含大量的==native== 方法
- 直接调用会报出==安全异常==
- 单例模式

> 源码

```java
public final int getAndAddInt(Object o, long offset, int delta) {
    int v;
    do {
        v = getIntVolatile(o, offset);
    } while (!weakCompareAndSetInt(o, offset, v, v + delta));
    return v;
}
```

```java
public final boolean weakCompareAndSetInt(Object o, long offset,
                                          int expected,
                                          int x) {
    return compareAndSetInt(o, offset, expected, x);
}
```

```java
@HotSpotIntrinsicCandidate
public final native boolean compareAndSetInt(Object o, long offset,
                                             int expected,
                                             int x);
```

> CAS的缺点

- 循环时间长,系统开销大,主要是CPU的消耗

- 只能保证一个共享变量的原子性操作,因为使用的是 ==this==

- ==**ABA**==问题 

  - 不同线程由于时间差的问题可能会使得共享变量实际发生了改变而外观上没有发生变化

  - 解决办法

    - 新增一种机制,修改版本号,类似时间戳.

      ```java
      import java.util.concurrent.TimeUnit;
      import java.util.concurrent.atomic.AtomicStampedReference;
      
      
      class TestAba {
          public static void main(String[] args) {
      
              AtomicStampedReference<Integer> reference = new AtomicStampedReference<Integer>(1, 0);
              new Thread(() -> {
                  int stamp = reference.getStamp();
                  try {
                      TimeUnit.SECONDS.sleep(2);
                  } catch (InterruptedException e) {
                      e.printStackTrace();
                  }
      
                  boolean b = reference.compareAndSet(1, 2, stamp, reference.getStamp() + 1);
                  System.out.println("第一次修改 " + b + " " + reference.getReference() + Thread.currentThread().getName());
                  boolean c = reference.compareAndSet(2, 1, reference.getStamp(), reference.getStamp() + 1);
                  System.out.println("第二次修改 " + c + " " + reference.getReference() + Thread.currentThread().getName());
      
      
              }, " A").start();
      
      
              new Thread(() -> {
                  int stamp = reference.getStamp();
                  try {
                      TimeUnit.SECONDS.sleep(4);
                  } catch (InterruptedException e) {
                      e.printStackTrace();
                  }
                  boolean b = reference.compareAndSet(1, 2, stamp, reference.getStamp() + 1);
                  System.out.println("第一次修改 " + b + " " + reference.getReference() + Thread.currentThread().getName());
              }, " B").start();
      
      
          }
      }
      ```

> 原子引用

- 对某个类进行原子包装

```java
import java.util.concurrent.atomic.AtomicReference;


public class User {
    String name;

    public User(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "User{" +
                "name='" + name + '\'' +
                '}';
    }
}


class Test {
    public static void main(String[] args) {
        User a = new User("a");
        User b = new User("b");

        AtomicReference<User> casAtomicReference = new AtomicReference<>();
        casAtomicReference.set(a);
        boolean b1 = casAtomicReference.compareAndSet(a, b);
        System.out.println(b1 + " " + casAtomicReference.get().toString());
        //true User{name='b'}
        boolean b2 = casAtomicReference.compareAndSet(a, b);
        System.out.println(b2 + " " + casAtomicReference.get().toString());
		//false User{name='b'}
    }
}
```